# 비트마스크

비트마스크를 사용한 기법과 유의사항

## 개요

CPU는 이진수를 이용해 모든 데이터를 처리한다. 내부적으로 이진수를 이용하는 컴퓨터들은 이진법과 관련한 연산을 아주 빠르게 할 수 있다. 이 이점을 활용하기 위해서 이진수 표현을 사용하는 기법을 비트마스크라고 한다. 비트마스크를 사용하면 아래와 같은 특징을 갖는다

1. 빠른 수행시간
1. 간결한 코드
1. 적은 메모리 사용
1. 연관 배열을 배열로 대체가능


### 비트 출력하기
우선 C에서 자료형에 담긴 값을 bit로 변환하여 출력해보자

``` cpp
template<typename DTYPE>
string convertBinary(DTYPE num, int digit)
{
    string res;
    while (--digit >= 0)
    {
        res += to_string((num >> digit) & 1);
        if (digit % 4 == 0) res += ' ';
    }
    return res;
}

int main()
{
    int a = 12;
    cout << convertBinary(a, 16) << '\n';
    return 0
}
```

```
0000 0000 0000 1100
```

매 bit 마다 bit shift를 통해서 각 비트의 값을 확인하고 이를 string에 넣는 과정을 통해 데이터를 bit로 변환하는 과정을 거쳤다. 각 4bit 마다 끊어서 담기도록 하였으며, 하위 'digit' bit를 변환 후 반환한다.


## bit 연산자

``` cpp
int a = 754;
int b = 470;
```


### AND
```cpp
// AND
c = a & b; // AND 연산 값을 c에 저장

cout << "      "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "AND   "<< convertBinary(b, 12) << " = " << b << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
      0010 1111 0010  = 754
AND   0001 1101 0110  = 470
─────────────────────────────
      0000 1101 0010  = 210
```

### OR
```cpp
c = a | b; // OR 연산 값을 c에 저장

cout << "      "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "OR    "<< convertBinary(b, 12) << " = " << b << '\n';
cout << "─────────────────────────────\n";
cout << "  
```
```
      0010 1111 0010  = 754
OR    0001 1101 0110  = 470
─────────────────────────────
      0011 1111 0110  = 1014
```

### XOR
```cpp
// XOR
c = a ^ b; // XOR 연산 값을 C에 저장

cout << "      "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "XOR   "<< convertBinary(b, 12) << " = " << b << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
      0010 1111 0010  = 754
XOR   0001 1101 0110  = 470
─────────────────────────────
      0011 0010 0100  = 804
```

### NOT
```cpp
// NOT
c = ~a; // NOT 연산 값을 C에 저장

cout << "NOT   "<< convertBinary(a, 32) << " = " << a << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 32) << " = " << c << '\n'
```
```
NOT   0000 0000 0000 0000 0000 0010 1111 0010  = 754
─────────────────────────────
      1111 1111 1111 1111 1111 1101 0000 1101  = -755
```

### bit shift
```cpp
c = a << 2;
cout << "<< 2  "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
<< 2  0010 1111 0010  = 754
─────────────────────────────
      1011 1100 1000  = 3016
```
왼쪽으로 2bit 만큼 bit shift


```cpp
c = a >> 2;
cout << ">> 2  "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
>> 2  0010 1111 0010  = 754
─────────────────────────────
      0000 1011 1100  = 188
```
오른쪽으로 2bit 만큼 bit shift

bitshift 연산자는 lvalue를 rvalue만큼 bit shift 한 결과를 반환한다.


## 주의할 점


## 비트마스크를 이용한 집합

비트 마스크를 이용하면 집합을 구현하면 적은 메모리와 다양한 최적화 기법으로 빠른 수행시간의 동작을 기대할 수 있다.

> Q : bool 배열과의 차이는 무엇인가?
>
> 비트마스크를 이용해 집합을 구현하면 bool 배열에 대비해서 1/8 크기의 메모리만을 사용한다. bool은 1Byte의 크기를 갖는데 비해 비트 마스크를 이용하면 1bit만의 공간을 차지한다.
또한 bit mask를 이용하면 연산자가 CPU 명령어로 바로 치환되거나, 내장 함수 사용시 다양한 최적화 기법을 사용하여 데이터를 처리한다. 컴퓨터는 32bit, 64bit 단위로 데이터를 처리하기 때문에 수행시간에서의 큰 향상이 가능하다.

비트 단위로 집합을 구현했을 때 아래와 같은 기법들을 사용할 수 있다.

기능|구현|설명
-|-|-
공집합|int set = 0;|모든 원소 없음
가득찬 집합|int set = (1 << k) - 1;|크기가 k인 집합(k만큼 1로 채워짐)
원소 추가|set \|= (1 << p);|번호가 p인 원소 추가
원소 삭제|set &= ~(1 << p)|번호가 p인 원소 삭제
원소 포함 여부 확인|if(set & (1 << p));|p번 원소가 존재하는가
원소 토글|set ^= (1 << p)|p번 원소 토글
두 집합 연산|< a & b, a \| b, a & ~b, a ^ b>| 교집합, 합집합, 차집합, 한 집합에만 존재
집합 크기 구하기|int bitCount(int x) {return x % 2 + bitCount(x / 2);}|1인 비트 수 반환
최소 원소 찾기|int first = (set & -set)|가장 처음으로 1이 등장하는 위치
최소 원소 지우기|set &= set - 1|set에서 최소 원소 비트 0으로(거듭제곱 판정에도 사용)
모든 부분 집합 순회|for (int subset = set; subset = ((subset-1) & set))| -1하여 모든 비트 경우를 순회


### 공집합

### 가득찬 집합

### 원소 추가

### 원소 포함 여부 확인

### 원소 삭제

### 원소 토글

### 두 집합 연산

### 집합 크기 구하기

### 최소 원소 찾기

### 최소 원소 지우기

### 모든 부분 집합 순회