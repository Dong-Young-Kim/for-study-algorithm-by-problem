# 비트마스크

비트마스크를 사용한 기법과 유의사항

## 개요

CPU는 이진수를 이용해 모든 데이터를 처리한다. 내부적으로 이진수를 이용하는 컴퓨터들은 이진법과 관련한 연산을 아주 빠르게 할 수 있다. 이 이점을 활용하기 위해서 이진수 표현을 사용하는 기법을 비트마스크라고 한다. 비트마스크를 사용하면 아래와 같은 특징을 갖는다

1. 빠른 수행시간
1. 간결한 코드
1. 적은 메모리 사용
1. 연관 배열을 배열로 대체가능


## 비트 출력하기
우선 C에서 자료형에 담긴 값을 bit로 변환하여 출력해보자

``` cpp
template<typename DTYPE>
string convertBinary(DTYPE num, int digit)
{
    string res;
    while (--digit >= 0)
    {
        res += to_string((num >> digit) & 1);
        if (digit % 4 == 0) res += ' ';
    }
    return res;
}

int main()
{
    int a = 12;
    cout << convertBinary(a, 16) << '\n';
    return 0
}

```

```
0000 0000 0000 1100
```

매 bit 마다 bit shift를 통해서 각 비트의 값을 확인하고 이를 string에 넣는 과정을 통해 데이터를 bit로 변환하는 과정을 거쳤다. 각 4bit 마다 끊어서 담기도록 하였으며, 하위 'digit' bit를 변환 후 반환한다.


## bit 연산자

``` cpp
int a = 754;
int b = 470;
```


### AND
```cpp
// AND
c = a & b; // AND 연산 값을 c에 저장

cout << "      "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "AND   "<< convertBinary(b, 12) << " = " << b << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
      0010 1111 0010  = 754
AND   0001 1101 0110  = 470
─────────────────────────────
      0000 1101 0010  = 210
```

### OR
```cpp
c = a | b; // OR 연산 값을 c에 저장

cout << "      "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "OR    "<< convertBinary(b, 12) << " = " << b << '\n';
cout << "─────────────────────────────\n";
cout << "  
```
```
      0010 1111 0010  = 754
OR    0001 1101 0110  = 470
─────────────────────────────
      0011 1111 0110  = 1014
```

### XOR
```cpp
// XOR
c = a ^ b; // XOR 연산 값을 C에 저장

cout << "      "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "XOR   "<< convertBinary(b, 12) << " = " << b << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
      0010 1111 0010  = 754
XOR   0001 1101 0110  = 470
─────────────────────────────
      0011 0010 0100  = 804
```

### NOT
```cpp
// NOT
c = ~a; // NOT 연산 값을 C에 저장

cout << "NOT   "<< convertBinary(a, 32) << " = " << a << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 32) << " = " << c << '\n'
```
```
NOT   0000 0000 0000 0000 0000 0010 1111 0010  = 754
─────────────────────────────
      1111 1111 1111 1111 1111 1101 0000 1101  = -755
```

### bit shift
```cpp
c = a << 2;
cout << "<< 2  "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
<< 2  0010 1111 0010  = 754
─────────────────────────────
      1011 1100 1000  = 3016
```
왼쪽으로 2bit 만큼 bit shift


```cpp
c = a >> 2;
cout << ">> 2  "<< convertBinary(a, 12) << " = " << a << '\n';
cout << "─────────────────────────────\n";
cout << "      "<< convertBinary(c, 12) << " = " << c << '\n';
```
```
>> 2  0010 1111 0010  = 754
─────────────────────────────
      0000 1011 1100  = 188
```
오른쪽으로 2bit 만큼 bit shift

bitshift 연산자는 lvalue를 rvalue만큼 bit shift 한 결과를 반환한다.

