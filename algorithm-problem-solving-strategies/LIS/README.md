# Longest Increasing Sequence

## 문제

어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열 (subsequence) 를 얻을 수 있다. 예를 들어 10 7 4 9 의 부분 수열에는 7 4 9, 10 4, 10 9 등이 있다. 단, 10 4 7 은 원래 수열의 순서와 다르므로 10 7 4 9 의 부분 수열이 아니다.

어떤 부분 수열이 순증가할 때 이 부분 수열을 증가 부분 수열 (increasing subsequence) 라고 한다. 주어진 수열의 증가 부분 수열 중 가장 긴 것의 길이를 계산하는 프로그램을 작성하라.

어떤 수열의 각 수가 이전의 수보다 클 때, 이 수열을 순증가 한다고 한다.

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열에 포함된 원소의 수 N (<= 500) 이 주어진다. 그 다음 줄에 수열이 N개의 정수가 주어진다. 각 정수는 1 이상 100,000 이하의 자연수이다.

### 출력

각 테스트케이스마다 한 줄씩, 주어진 수열의 가장 긴 증가 부분 수열의 길이를 출력한다.

### 예제 입력

```
3
4
1 2 3 4
8
5 4 3 2 1 6 7 8 
8
5 6 7 8 1 2 3 4
```

### 예제 출력

```
4
4
4
```

---

## 문제해결

### DP를 이용한 O(n^2) 알고리즘

'현재 탐색하고 있는 A[i]'를 기준으로, '배열 우측에 있는 자신 보다 큰 임의의 A[i + a]들 중'에서 최대 길이를 만들 수 있는 A[j]를 찾으면 된다.

이 과정은 재귀 호출을 통해서 구현할 수 있고, A[i]는 A[j] 이후 배열이 어떠한지에 상관이 없이 문제의 조건이 충족되므로 부분최대구조를 만족한다. 따라서 현재 A[i] 까지 만들 수 있는 최대 수열의 길이를 캐시에 저장하면 중복된 계산을 피할 수 있다.


### 모든 시작 위치를 순회하지 않고 답 구하기

찾은 LIS가 어디서부터 순화할지 모르므로 모든 시작위치를 가정하고 답을 구해야 한다.
즉 find(0)만 호출하면 답이 나오는 것이 아니라 find(0)부터 find(N) 까지 모든 함수를 호출한 후 이 중 최대값을 문제의 답으로 결정해야하는 번거로움이 있다.

이를 해결하기 위해서는 간단한 트릭을 사용하면 되는데
입력된 수열의 -1 index에 가상의 최소값을 가정하고 find(-1)을 호출하면 find(-1)이 알아서 모든 값을 순회하는 효과를 얻게된다.
이때 find(-1)의 값은 가상의 값을 포함한 LIS의 크기이므로 찾은 결과에서 -1을 빼면 결과를 구할 수 있다.

### DP를 이용한 O(nlogn) 알고리즘


> 재귀 없이 풀어보기

#### py additional
``` py
n = int(input())
arr = list(map(int,input().split()))
cnt = [1] * n

for i in range(n):
	for j in range(i):
		if arr[j] < arr[i]:
			cnt[i] = max(cnt[i], cnt[j]+1)

print(max(cnt))
```

``` cpp
#include <iostream>
using namespace std;

int dp[1001];
int arr[1001];

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> dp[i];
	}
	
	int sum = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < i; j++) {
			if (dp[i] > dp[j]) {
				arr[i] = max(arr[j] + 1, arr[i]);
			}
		}
		sum = max(sum, arr[i]);
	}

	cout << ++sum;
	return 0;
}
```