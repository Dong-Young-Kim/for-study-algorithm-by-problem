# 폴리오미노

## 문제

정사각형들의 변들을 서로 완전하게 붙여 만든 도형들을 폴리오미노(Polyomino)라고 부릅니다. n개의 정사각형으로 구성된 폴리오미노들을 만들려고하는데, 이 중 세로로 단조(monotone)인 폴리오미노의 수가 몇 개나 되는지 세고 싶습니다. 세로로 단조라는 말은 어떤 가로줄도 폴리오미노를 두 번 이상 교차하지 않는다는 뜻입니다.

![이미지](https://algospot.com/media/judge-attachments/1f80fe48fcd9234b6a70d2bf940c934c/poly.png)

예를 들어 그림 (a)는 정상적인 세로 단조 폴리오미노입니다. 그러나 (b)는 점선이 폴리오미노를 두 번 교차하기 때문에 세로 단조 폴리오미노가 아닙니다. (c)는 맨 오른쪽 아래 있는 정사각형이 다른 정사각형과 변을 완전히 맞대고 있지 않기 때문에 폴리오미노가 아닙니다.

n개의 정사각형으로 구성된 세로 단조 폴리오미노의 개수를 세는 프로그램을 작성하세요.

### 입력
입력의 첫 줄에는 테스트 케이스의 수 C (1≤C≤50)가 주어집니다. 그 후 각 줄에 폴리오미노를 구성할 정사각형의 수 n (1≤n≤100)이 주어집니다.

### 출력
각 테스트 케이스마다, n개의 정사각형으로 구성된 세로 단조 폴리오미노의 수를 출력합니다. 폴리오미노의 수가 10,000,000 이상일 경우 10,000,000으로 나눈 나머지를 출력합니다.

### 예제 입력
```
3
2
4
92
```
### 예제 출력
```
2
19
4841817
```

--- 

## 문제 해결

### 문제 이해
문제의 '세로로 단조(monotone)' 조건에 의해서 이 문제는 '각 가로 줄에 몇개의 정사각형을 배치해야 하는가'의 문제로 치횐이 가능하다. 즉 한 가로줄에 모든 정사각형이 배치되어 있으므로, 한 줄에 몇개의 정사각형이 배치될 것인지만 정해진다면 이를 좌우로 이동하는 경우의 수만 고려하면 된다.

### 문제 해결
문제의 해결과정을 간략화하면 아래와 같다.
1. 맨 윗 줄 부터 몇개의 정사각형을 배치할지를 결정한다.
2. 그 다음줄에 몇개의 정사각형이 배치될지를 정한다.
3. 윗줄과 아랫줄에 배치되는 정사각형 수를 f, s라 한다면 이 두 줄의 조합은 (f + s -1)이다.
4. 다음 줄 부터는 재귀 호출하여 차례대로 계산한다.

위 해결 과정을 통해 알 수 있듯이 현재 줄의 조합을 계산하려면 '다음에 놓일 정사각형 묶음의 첫 번쨰 줄에 놓일 정사각형의 개수'를 알아야 한다. 이를 알기 위해서 함수 호출 시에 해당 값을 함수의 인자로서 입력한다.

### 재귀 호출 결정

``` cpp
// n = 배치할 정사각형의 수
// first = 첫번쨰에 놓일 정사각형 수
poly(n, first)
```
poly를 위와 같이 정의 한다면 점화식을 작성할 수 있다.

```
poly(n,first) 
    = sum (i = 1; i <= n - first; i++)
    {
        (first + i - 1) * poly(n - first, i)
    }
```

처음 poly 재귀 함수를 호출하는 경우는 i = 1 부터 i <= N 까지 전부 호춣한 후, 이를 모두 더한 값을 정답으로 출력한다.
다만 계산 과정 중 overflow를 방지하기 위해서 '+=' 연산시 마다 modular 연산을 추가한다.

## 추가

### Modular(%) 연산
modular 연산은 덧셈 곱셈 뺄샘의 경우에는 분배법칙(연산 순서에 상관없이)이 항상 성립힌다.

```
(a+b) % M = ((a % M) + (b % M)) % M
(a-b) % M = ((a%M) - (a%M)) % M
(a*b) % M = ((a*M) * (b*M)) % M
```

나눗셈 연산에서는 곱셈 역원을 곱하는 방식으로 이루어지는데, 곱셈 역원은 항상 존재하는 것이 아니라, 나누는 수 b와 M이 서로소인 경우에만 존재한다.

---

***본 문제의 출처는 '알고스팟(https://algospot.com)'에 있으며, 풀이 소스코드의 일부는 '알고리즘 문제해결 전략'을 참고하여 작성되었습니다.***