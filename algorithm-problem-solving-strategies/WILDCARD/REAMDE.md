# Wildcard

## 문제
와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다. 와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다.

와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자. 단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다.

예를 들어 와일드 카드 he?p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다. 와일드 카드 *p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다.

와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.

### 입력
입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 10) 가 주어진다. 각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N (1 <= N <= 50) 이 주어진다. 그 후 N 줄에 하나씩 각 파일명이 주어진다. 파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에 * 와 ? 를 가질 수 있다. 모든 문자열의 길이는 1 이상 100 이하이다.

### 출력
각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.

### 예제 입력

```
2
he?p
3
help
heap
helpp
*p*
3
help
papa
hello
```

### 예제 출력

```
heap
help
help
papa
```



## 문제 해결

### 단계적으로 해결해보자

#### 1. '*' 이 없는 경우

패턴과 타깃의 문자를 하나씩 검사한다. 이때 '?'가 등장하는 경우를 추가적으로 처리한다.

for 문을 이용해 pos < p.size() && pos < t.size() 범위에 대해서 문자를 하나씩 대조 p와 t 모두 끝에 도달하였으면 true를 반환한다.


#### 2. 재귀 호출 알고리즘

'*'를 처리하는 과정을 추가해야 한다. '*'의 처리가 어려운 이유는 target의 몇 글자가 '*'에 대응되는지 모르기 때문이다.

*가 등장하면 * 가 몇 글자에 대응되는지 0글자부터 남은 글자수 만큼의 경우를 모두 재귀호출하여 해결할수 있다.

``` cpp
if (p[pos] == '*')
{
    for (int k = pos; k <= t.size(); k++)
    {
        if(match(p.substr(pos+1), t.substr(k))) return true;
    }
}
```

*에 문자가 전혀 해당되지 않는 경우부터 남은 모든 문자열이 해당되는 경우까지 전부를 substr 함수를 통해 재귀 호출한다. 하나의 경우라도 성립되는 경우 전부 매칭이 성공한 것이므로 가장 처음 성공하는 경우를 성공한 케이스로 판단할 수 있다.


#### 3. DP를 이용한 실행시간 개선

> 무엇을 캐싱해야 중복되는 문제를 계산할 수 있는가

패턴의 시작 index i, 타깃의 시작 인덱스 j일때 i와 j 쌍에 대한 매칭 가능 여부를 cache에 저장해 메모이제이션 할 수 있다.

재귀로 작성한 프로그램과 DP로 구현한 프로그램은 
- 계산 결과를 저장하는 cache의 사용유무
- match함수에 넘기는 parameter를 string 자체에서 index로 변경한 것
- pos 변수 대신 pi와 ti로 전역성을 갖는 인수료 변환 한 것
외에 모든 구현 원리가 동일하다.

#### 4. 추가적 실행시간 개선