# boj 6087 : 레이저 통신

# 입력된 평면에서 C 와 C를 연결하는 최소 거울의 개수를 구하는 문제

"""
거울의 의미 -> 회전
회전이 한 번 추가될 때 마다 cost가 추가되는 것

완전 탐색 : 평면 어느 위치에 거울을 놓을지 조합을 결정하는 것 -> O(2^N) 평면에 각 지점에 거울을 놓을것 인지 말지

BFS 탐색
4방향으로 탐색하면서, 벽이 나타날 때 까지 C를 탐색한다.

답이 존재하지 않는다면 탐색한 위치에서 새로 탐색한다. (= 방향을 꺽는다)
이때 현재 위치가 몇번째로 탐색된 위치인지를 기록해놓아야 한다.
(그래프 탐색에서 사용하는 visited 배열을 응용하여 -1부터 순차적으로 기록할 것)
-> 주어진 입력에 하나의 결과만 도출하면 되므로 원본 보존하지 않아도 상관 없다.
-> 입력 받은 board 배열에 숫자를 표시하여 필요한 거울 수를 표시할 수 있을 것

if 세로 방향 탐색시
"""

import sys
from collections import deque

def outOfRange(x, y):
    return x < 0 or x >= H or y < 0 or y >= W

# based on bfs
def solve():
    queue = deque()
    queue.append(cs)
    board[cs[0]][cs[1]] = -1 # to mark start origin
    while True:
        node = queue.popleft()

        for dir in [(-1,0), (1,0), (0,-1), (0,1)]: # N, S, W, E
            mirror_need = board[node[0]][node[1]] + 1

            nx, ny = node[0], node[1]
            while True: # visit all at same lines
                nx += dir[0]
                ny += dir[1]
                if outOfRange(nx, ny): break

                makr = board[nx][ny]
                if makr == 'C':
                    return mirror_need
                elif makr == '*':
                    break
                elif makr == '.':
                    queue.append((nx, ny))
                    board[nx][ny] = mirror_need
                else: # integer
                    pass


W, H = map(int, sys.stdin.readline().split())
board = [list(list(sys.stdin.readline())) for _ in range(H)]
cs, ce = 0, 0 # cs : cow start, ce : cow end
flag = False
for i in range(W * H):
    if (board[i // W][i % W]) == 'C':
        if not flag:
            cs = (i // W, i % W)
            flag = True
        else:
            ce = (i // W, i % W)
            break
  
print(solve())

"""
공백 없는 문자열 입력받기

1. 문자열을 입력받아서 리스트로 변환
문자열이 공백으로 구분되지 않으므로 input에 list로 자료형을 변환하여 각 문자를 리스트로 변환한다.
길이를 알고 있으므로 마지막의 개행문자는 무시해도 좋다.
board = [list(list(sys.stdin.readline())) for _ in range(H)]

2. 문자열을 입력받아서 1차원 리스트로 저장
1차원 리스트에 문자열을 입력하는 방법도 있다.
board = [input() for _ in range(H)]

"""

"""
TC
36 40
*...................................
.*..*....************************...
..*..*...*C.....................*...
......*..********************...*...
.............................*.*....
..************************..*...*...
.*.......................*.*...*...*
*..********************..*..**.*....
......................*.....*..*....
............*..........*.*.*....*...
*******************.*..**.*.....*...
..................*...*........*....
.**************...*...*.*******...*.
..............*...*...*.............
.*............*...*...*...*.........
.*.************...*...*..*.*........
**............*...*...*.*...*.......
..*...........*...*...**.....*......
...*..........*...*...*.*.....*.....
....*.........*...*...*..*..........
.....*........*...*...*...*.........
......*.......*.*.*...*....*.......*
.......*......*...*...*.....*.....*.
*************.*...*...*......*...*..
*.............*...*...*.......*.*...
*..*..*...*....*..**..*........*....
*..*.*.*.*.**.*...*...*.............
*..**...*....*....*...*.............
*..*..............*...*.............
*..*.**************...*.............
*..*..............*...*.............
**C*.............*....*.............
..*.............*.....*.............
...............*......*.............
......................*.............
......................*.............
***.***.*.*.*.***.***..*..*.*...***.
*...*.*.*.*.*.**..***..*..*.*...**..
*...*.*..*.*...**.*.*..*..*.*...*...
***.***..*.*..***.*..*.****.***.***.
=>  27
"""